alias kcn="kubens"

alias kc="kubectl"

# krew
alias kck="kc krew"
alias kcki="kck install"
alias kckr="kck remove"
alias kckl="kck list"
alias kcks="kck search"
alias kcku="kck update"

# kc plugins
alias kce="kc iexec"
alias kct="kc tail"
alias kcs="kc sniff"

# kc logs
alias kcl="kc logs"
alias kclf="kc logs -f"

# kc get
alias kcg="kc get"
alias kcga="kcg all"
alias kcgn="kcg node -o wide"
alias kcgns="kcg namespaces"
alias kcgs="kcg svc -o wide"
alias kcgd="kcg deploy"
alias kcgds="kcg ds"
alias kcge="kcg ev --sort-by=.metadata.creationTimestamp -w"

# kc get deploy
alias kcgdc="kcgd -o custom-columns='NAME:metadata.name,REPLICAS:spec.replicas,AVAILABLE:status.availableReplicas,CONTAINER:spec.template.spec.containers[*].name'"
alias kcgdci="kcgd -o custom-columns='NAME:metadata.name,REPLICAS:spec.replicas,AVAILABLE:status.availableReplicas,INITCONTAINER:spec.template.spec.initContainers[*].name'"
alias kcgdn="kcgd -o custom-columns='NAME:metadata.name,REPLICAS:spec.replicas,AVAILABLE:status.availableReplicas,DNSPOLICY:spec.template.spec.dnsPolicy,HOSTNETWORK:spec.template.spec.hostNetwork'"

# kc get pod
alias kcgp='kcgp(){if [ -z $RUN ];then;kcg pod $@;else;if [ $RUN -eq 0 ];then;kcg pod --field-selector=status.phase!=Running $@;else;kcg pod --field-selector=status.phase==Running $@;fi;fi;};kcgp $@'
alias kcgpn="kcgp -o custom-columns='NAME:metadata.name,NODE:spec.nodeName,DNSPOLICY:spec.dnsPolicy,HOSTNETWORK:spec.hostNetwork,PORTS:spec.containers[*].ports'"
alias kcgpc="kcgp -o custom-columns='NAME:metadata.name,UID:metadata.uid,CONTAINER:spec.containers[*].name'"
alias kcgpci="kcgp -o custom-columns='NAME:metadata.name,UID:metadata.uid,INITCONTAINER:spec.initContainers[*].name'"
alias kcgps="kcgp -o custom-columns='NAME:metadata.name,SERVICEACCOUNT:spec.serviceAccountName'"
alias kcgpv="kcgp -o custom-columns='NAME:metadata.name,NODE:spec.nodeName,VOLUMES:spec.volumes[*].name'"
alias kcgpi="kcgp -o custom-columns='NAME:metadata.name,IMAGES:spec.containers[*].image'"
alias kcgpip="kcgp -o custom-columns='NAME:metadata.name,PULLPOLICY:spec.containers[*].imagePullPolicy'"
alias kcgpil="kcgp -o custom-columns='IMAGES:spec.containers[*].image' --no-headers | tr ',' '\n' | sort -u"
alias kcgpila="kcgp --all-namespaces -o custom-columns='IMAGES:spec.containers[*].image' --no-headers | tr ',' '\n' | sort -u"
alias kcgpp="kcgp -o custom-columns='NAME:metadata.name,LIVENESS:spec.containers[*].livenessProbe,READINESS:spec.containers[*].readinessProbe'"

# kc get other
alias kcgnds="kcgp -o custom-columns='NAME:metadata.name,NODESELECTOR:spec.nodeSelector'"
alias kcgpvc="kcgp -o custom-columns='NAME:metadata.name,NODESELECTOR:spec.volumes[*].persistentVolumeClaim'"

# others
alias kcdpe="kc delete pod --field-selector=status.phase!=Running"
alias kctpc="kc top pod --containers"
alias kcwpr="kc wait --for condition=ready pod --all"
alias kcapi="kc api-resources"
alias kcdns="pod2xsv | xsv search -s HOSTNETWORK true | xsv search -v -s DNSPOLICY ClusterFirstWithHostNet | xsv select NAME,NAMESPACE,HOSTNETWORK,DNSPOLICY | xsv table"
alias kcgcs="kc config view --minify --output 'jsonpath={..server}'"
alias kcgcn="kc config view --minify --output 'jsonpath={..namespace}'"
alias kc?='echo "[cluster] $(kcgcs)"; echo "[namespace] $(kcgcn)";'

# context
ccc(){
  local WSLKUBECONFIGDIR=/mnt/c/Users/${USER}
  local WSLKUBECONFIG=${WSLKUBECONFIGDIR}/.kube/config
  local KUBECONFIG=${HOME}/.kube/config
  local NAME=$(ls ${HOME}/.kube | grep .config | cut -d "." -f 1 | fzf)
  cf ${KUBECONFIG} ${NAME}
    if [ -d ${WSLKUBECONFIGDIR} ];then
    cp ${KUBECONFIG} ${WSLKUBECONFIG}
  fi
}
cccc(){
  local WSLKUBECONFIGDIR=/mnt/c/Users/${USER}
  local WSLKUBECONFIG=${WSLKUBECONFIGDIR}/.kube/config
  local KUBECONFIG=${HOME}/.kube/config
  local NAME=$(ls ${HOME}/.kube | grep .config | cut -d "." -f 1 | fzf)
  cf ${KUBECONFIG} ${NAME}
  sed  -i 's/server:.*/server: http:\/\/127.0.0.1:8001/g' ${KUBECONFIG}
  if [ -d ${WSLKUBECONFIGDIR} ];then
    cp ${KUBECONFIG} ${WSLKUBECONFIG}
  fi
  echo "proxy to ${NAME}"
  KUBECONFIG=${KUBECONFIG}.${NAME} kubectl proxy
}

# set
alias kcs='kc set'
alias kcse='kc set env'
alias kcsi='kc set image'
alias kcsr='kc set resources'
alias kcss='kc set selector'
# rollout
alias kcr='kc rollout'
alias kcru='kc rollout undo'
alias kcrs='kc rollout status'
alias kcrr='kc rollout restart'
alias kcrh='kc rollout history'
alias kcrp='kc rollout pause'
# run
alias kcrun='kuberun(){kc create deploy $1 --image=$2;kc expose deploy $1 --port=$3 --target-port=$3;};kuberun $@'
# explain
alias kcexp='kc explain --recursive'
# shell
alias kcshell='kc delete pod dummy --ignore-not-found && kc run -i --rm --restart=Never dummy --image=nicolaka/netshoot --command -- bash -il'
# node
kcnode(){
    kc describe node $(kcgn -o wide --no-headers | fzf | awk '{print $1}')
}
# apply
alias kcaf='kc apply -f'
# virtctl
alias kcvt='kc virt'

# tshark
kubeshark(){
local CTL=$1
local BPF="port 8001"
local METHODS="${2:-GET|PUT|POST|DELETE}"
local DISPLAY="http.request"
DISPLAY="${DISPLAY} && http.user_agent contains \"${CTL}\""
DISPLAY="${DISPLAY} && http.request.uri != \"/api/v1/namespaces/kube-system/configmaps/${CTL}-controllers\""
DISPLAY="${DISPLAY} && http.request.method matches \"($METHODS)\""
DISPLAY=${3:-$DISPLAY}
echo ${DISPLAY}
local LO="lo"
local TSHARK="tshark"
type wsl.exe >/dev/null 2>&1
if [ $? -eq 0 ]; then
LO="Adapter for loopback traffic capture"
TSHARK="tshark.exe"
fi
${TSHARK} -i "${LO}" -f "${BPF}" -Y "${DISPLAY}"  -T fields -E separator=" | " -e http.request.method -e http.request.uri
}

#
kcnp(){
    kcg svc -A -ojson  | jq -r '.items[] | select(.spec.type == "NodePort") | {"name":.metadata.name,"port":.spec.ports[].nodePort}'
}
kcpnp(){
    kc patch svc $1 -p '{"spec":{"type":"NodePort"}}'
    kc get svc $1 -owide
}
